{% extends 'layout.html' %} {% block css %} {% endblock %} {% block content %}

<!-- Field Creation Modal -->
<field-builder-drawer :model-value="isFieldBuilderDrawerOpen" @update:model-value="closeDrawer" @save="saveField" :item="editedItem" entity-type="bulletin"></field-builder-drawer>

<v-main>
  <v-container fluid>
    <v-card style="height: calc(100vh - 100px)">
      <v-toolbar class="flex-md-column">
        <v-toolbar-title>{{ _('Bulletin Fields Configuration') }}</v-toolbar-title>

        <template #append>
          <v-text-field
            density="compact"
            class="mr-2"
            placeholder="{{ _('Search') }}"
            prepend-inner-icon="mdi-magnify"
            max-width="300px"
            width="200px"
            hide-details
            v-model="search"
          ></v-text-field>
          <v-btn
            prepend-icon="mdi-plus"
            class="mr-2"
            variant="outlined"
            @click="isFieldBuilderDrawerOpen = true"
            >{{ _('Add new field') }}</v-btn
          >
          <v-btn @click="showSaveDialog()" prepend-icon="mdi-check" class="mr-4" color="primary" variant="flat" :loading="loading" :disabled="!hasChanges"
            >{{ _('Save changes') }}</v-btn
          >
        </template>
      </v-toolbar>

      <v-card-text class="d-flex flex-column ga-4 overflow-y-scroll" style="height: calc(100vh - 165px);">
        <span class="text-h6 font-weight-bold">Core fields</span>
        <draggable
          v-model="dynamicFields"
          :item-key="'id'"
          tag="v-row"
          handle=".drag-handle"
          @end="onDragEnd"
          class="flex-0-0"
        >
          <template #item="{ element: field }">
            <v-col v-if="matchesSearch(field) && !field._force_deleted" cols="12">
              <v-row>
                <v-col cols="12" lg="6">
                  <field-list-item
                    :field="field"
                    :component-props="mapFieldToComponent(field)"
                    @edit="edit"
                    @toggle-visibility="toggleFieldVisibility"
                    @delete="deleteField"
                  />
                </v-col>
              </v-row>
            </v-col>
          </template>
        </draggable>
        <v-btn prepend-icon="mdi-plus" class="mr-2" variant="outlined" @click="isFieldBuilderDrawerOpen = true">{{ _('Add new field') }}</v-btn>
      </v-card-text>
    </v-card>
  </v-container>

  <v-dialog v-model="saveChangesDialog" max-width="900">
    <v-card>
      <v-card-title class="d-flex justify-space-between align-center">
        {{ _('Review and confirm your changes') }}
        <v-btn icon="mdi-close" variant="text" @click="saveChangesDialog = false"></v-btn>
      </v-card-title>
      <v-card-text class="d-flex pb-2 pt-2">
        <div class="d-flex align-center body-2">
          <v-avatar class="mr-2" size="18" color="red lighten-3"></v-avatar>
          {{ _('Old Value') }}
        </div>
      
        <div class="d-flex align-center ml-4 body-2">
          <v-avatar class="mr-2" size="18" color="green lighten-2"></v-avatar>
          {{ _('New Value') }}
        </div>
      </v-card-text>
      <v-card-text class="pa-4">
        <div v-if="configDiff">
          <diff-renderer :diff="configDiff"></diff-renderer>
        </div>
        <v-sheet v-else class=" text-center mt-3 align-center">
          <v-icon left>mdi-alert</v-icon>
          {{ _('No changes detected') }}
        </v-sheet>

        <v-alert v-if="changes.delete.length" type="warning" variant="tonal" class="mt-4">
          <div v-for="(change, index) in changes.delete" :key="index" class="d-flex align-center">
            <div class="d-flex align-center">
              {{ _('Field') }} <strong>&nbsp;${change.item.title}&nbsp;</strong> {{ _('will be deleted permanently') }}
            </div>
          </div>
        </v-alert>
  
      </v-card-text>
      <v-divider></v-divider>
      <v-card-actions class="pa-4 justify-end">
        <v-btn @click.stop="saveChangesDialog = false" class="grey lighten-4" elevation="0">{{ _('Cancel') }}
        </v-btn>
        <v-btn variant="elevated" color="primary" :loading="loading" :disabled="!configDiff" @click.stop="save()" class="ml-4">
          {{ _('Confirm') }}
        </v-btn>
      </v-card-actions>
  
    </v-card>
  </v-dialog>
</v-main>

{% endblock %} {% block outside %} {% endblock %} {% block js %}
<script src="/static/js/tinymce/js/tinymce/tinymce.min.js" referrerpolicy="origin"></script>
<script src="/static/js/tinymce-vue.min.js"></script>
<script src="/static/js/diff-tool.js"></script>
<script src="/static/js/Sortable.min.js"></script>
<script src="/static/js/vuedraggable.umd.js"></script>
<script src="/static/js/jsondiffpatch/jsondiffpatch.umd.slim.js"></script>

<script src="/static/js/components/FieldListItem.js"></script>
<script src="/static/js/components/FieldBuilderDrawer.js"></script>
<script src="/static/js/components/PopDateField.js"></script>
<script src="/static/js/components/PopDateTimeField.js"></script>
<script src="/static/js/components/PopDateRangeField.js"></script>
<script src="/static/js/components/DiffRenderer.js"></script>

<script>
    const { createApp } = Vue;
    const { createVuetify } = Vuetify;
    const vuetify = createVuetify(vuetifyConfig);

    const app = createApp({
      delimiters: delimiters,
      mixins: [globalMixin],
      data: () => ({
        tinyConfig: tinyConfig,
        drawer: drawer,
        isFieldBuilderDrawerOpen: false,
        editedItem: {},
        search: '',
        dynamicFields: [],
        searchQuery: '',
        loading: false,
        originalFields: [],
        configDiff: '',
        changes: '',
        saveChangesDialog: false,
      }),
      mounted() {
        this.fetchDynamicFields();
      },
      computed: {
        hasChanges() {
          const changes = this.computeChanges();
          return changes.create.length || changes.update.length || changes.delete.length;
        }
      },
      methods: {
        sortDynamicFields() {
          this.dynamicFields = this.dynamicFields.sort((a, b) => {
            if (a.sort_order === 0 && b.sort_order !== 0) return 1;  // a goes last
            if (b.sort_order === 0 && a.sort_order !== 0) return -1; // b goes last
            return a.sort_order - b.sort_order; // normal sort
          });
        },
        matchesSearch(field) {
          return !this.search || field.title?.toLowerCase().includes(this.search.toLowerCase());
        },
        edit({ field }) {
          const matchingField = this.dynamicFields.find(coreField => coreField.id === field.id)
          this.editedItem = matchingField;
          this.isFieldBuilderDrawerOpen = true;
        },
        saveField(evt) {
          let idx = this.dynamicFields.findIndex(coreField => coreField.id === evt.id)

          if (this.dynamicFields[idx] && evt.id) {
            // Update existing field
            this.dynamicFields[idx] = { ...evt }
          } else {
            // Add new field
            this.dynamicFields.push(evt)
          }

          this.sortDynamicFields()
        },
        async fetchDynamicFields() {
          try {
            const response = await axios.get('/admin/api/dynamic-fields/?entity_type=bulletin');
            this.dynamicFields = response.data.data;
            this.reindexZeroSortFields();
            this.sortDynamicFields();
            this.originalFields = JSON.parse(JSON.stringify(this.dynamicFields)); // deep clone
          } catch (err) {
            console.error(err);
            this.showSnack(handleRequestError(err));
          }
        },

        showSaveDialog() {
          this.changes = this.computeChanges();
          const dynamicFieldsWithoutBackupId = this.dynamicFields.map(field => {
            if (field.id?.startsWith?.('backup-')) {
              delete field.id; // Remove backup ID for diff
            }
            return field;
          });
          this.configDiff = DiffTool.getAndRenderDiff(this.originalFields, dynamicFieldsWithoutBackupId);
          this.saveChangesDialog = true;
        },

        async save() {
          this.loading = true;
          try {
            const changes = this.computeChanges();

            // Create
            for (const { item } of changes.create) {
              await axios.post(`/admin/api/dynamic-fields/`, { item });
            }
            // Update (full object)
            for (const { id, item } of changes.update) {
              await axios.put(`/admin/api/dynamic-fields/${id}`, { item });
            }
            // Delete
            for (const { id, item } of changes.delete) {
              if (!id || id?.startsWith?.('backup-')) {
                // Skip backup IDs
                continue;
              }

              await axios.delete(`/admin/api/dynamic-fields/${id}?${item._force_deleted ? 'force=true' : ''}`);
            }

            this.showSnack('{{ _("Fields saved successfully") }}');
            await this.fetchDynamicFields();
            this.saveChangesDialog = false;
            this.configDiff = '';
          } catch (err) {
            console.error(err);
            this.showSnack(handleRequestError(err));
          } finally {
            this.loading = false;
          }
        },

        computeChanges() {
          const changes = { create: [], update: [], delete: [] };
          const originalMap = new Map(this.originalFields.map(f => [f.id, f]));

          for (const field of this.dynamicFields) {
            if (field._force_deleted) {
              // Fully delete on save
              changes.delete.push({ id: field.id, item: field });
              originalMap.delete(field.id);
              continue;
            }

            if (!field.id || field.id?.startsWith?.('backup-')) {
              changes.create.push({ item: field });
            } else {
              const orig = originalMap.get(field.id);
              if (orig) {
                if (JSON.stringify(field) !== JSON.stringify(orig)) {
                  changes.update.push({ id: field.id, item: field });
                }
                originalMap.delete(field.id);
              }
            }
          }

          // Remaining originals are deleted (dynamic only)
          for (const field of originalMap.values()) {
            if (!field.core) {
              changes.delete.push({ id: field.id, item: field });
            }
          }

          return changes;
        },
        
        mapFieldToComponent(coreField) {
          const baseProps = {
            fieldId: coreField.id,
            label: coreField.title,
            name: coreField.name,
            variant: 'filled',
            disabled: !coreField.active,
            hint: coreField?.ui_config?.help_text,
          };

          const componentMap = {
            text_input: { component: 'v-text-field', ...baseProps },
            multi_select: { component: 'v-select', ...baseProps, items: coreField.options, 'item-title': 'label', 'item-value': 'value', multiple: coreField.field_type === 'array' },
            dropdown: { component: 'v-select', ...baseProps, items: coreField.options, 'item-title': 'label', 'item-value': 'value', multiple: coreField.field_type === 'array' },
            text_area: { component: 'v-textarea', ...baseProps },
            checkbox: { component: 'v-checkbox', ...baseProps },
            switch: { component: 'v-switch', ...baseProps },
            date_picker: { component: 'pop-date-time-field' },
            editor: { component: 'tinymce-editor', init: tinyConfig, disabled: !coreField.active, fieldId: coreField.id },
          };

          const config = componentMap[coreField.ui_component];
          if (!config) return null;

          return config;
        },
        onDragEnd() {
          this.reindexFields()
        },
        reindexFields() {
          this.dynamicFields = this.dynamicFields.map((field, index) => ({ ...field, sort_order: index+1 }))
        },
        reindexZeroSortFields() {
          // Find max sort_order before first zero
          let maxOrder = 0;
          for (const field of this.dynamicFields) {
            if (field.sort_order === 0) break;
            if (field.sort_order > maxOrder) maxOrder = field.sort_order;
          }

          let counter = maxOrder + 1;

          this.dynamicFields = this.dynamicFields.map(field => {
            if (field.sort_order === 0) {
              return { ...field, sort_order: counter++ };
            }
            return field;
          });
        },
        async deleteField({ field, force = false }) {
          try {
            const matchingField = this.dynamicFields.find(coreField => coreField.id === field.id)
            
            if (force) {
              // Remove from the array immediately (frontend only)
              matchingField.active = matchingField.active !== field.active ? field.active : true;
              matchingField._force_deleted = true;
            } else {
              // Soft delete
              matchingField.active = false;
            }
          } catch (err) {
            console.error(err);
            this.showSnack(handleRequestError(err));
          }
        },
        async toggleFieldVisibility({ field }) {
          try {
            const matchingField = this.dynamicFields.find(coreField => coreField.id === field.id)
            matchingField.active = !matchingField.active
          } catch (err) {
            console.error(err);
            this.showSnack(handleRequestError(err));
          }
        },
        closeDrawer(open) {
          this.isFieldBuilderDrawerOpen = open;
          this.editedItem = {}
        }
      },
    });

    app.component('FieldListItem', FieldListItem);
    app.component('FieldBuilderDrawer', FieldBuilderDrawer);
    app.component('draggable', vuedraggable);
    app.component('tinymce-editor', Editor);
    app.component('PopDateField', PopDateField);
    app.component('PopDateRangeField', PopDateRangeField);
    app.component('PopDateTimeField', PopDateTimeField);
    app.component('DiffRenderer', DiffRenderer);

    app.use(router);
    app.use(vuetify).mount('#app');

    window.app = app;
</script>
{% endblock %}
