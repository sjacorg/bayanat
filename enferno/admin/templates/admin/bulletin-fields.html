{% extends 'layout.html' %} {% block css %} {% endblock %} {% block content %}

<!-- Field Creation Modal -->
<field-builder-drawer :model-value="isFieldBuilderDrawerOpen" @update:model-value="closeDrawer" @save="saveField" :item="editedItem" entity-type="bulletin"></field-builder-drawer>

<v-main>
  <v-container fluid>
    <v-card style="height: calc(100vh - 100px)">
      <v-toolbar class="flex-md-column">
        <v-toolbar-title>{{ _('Bulletin Fields Configuration') }}</v-toolbar-title>

        <template #append>
          <v-text-field
            density="compact"
            class="mr-2"
            placeholder="{{ _('Search') }}"
            prepend-inner-icon="mdi-magnify"
            max-width="300px"
            width="200px"
            hide-details
            v-model="search"
          ></v-text-field>
          <v-btn
            prepend-icon="mdi-plus"
            class="mr-2"
            variant="outlined"
            @click="isFieldBuilderDrawerOpen = true"
            >{{ _('Add new field') }}</v-btn
          >
          <v-btn @click="save()" prepend-icon="mdi-check" class="mr-4" color="primary" variant="flat" :loading="loading" :disabled="!hasChanges"
            >{{ _('Save changes') }}</v-btn
          >
        </template>
      </v-toolbar>

      <v-card-text class="d-flex flex-column ga-4 overflow-y-scroll" style="height: calc(100vh - 165px);">
        <span class="text-h6 font-weight-bold">Core fields</span>
        <draggable
          v-model="dynamicFields"
          :item-key="'id'"
          tag="v-row"
          handle=".drag-handle"
          @end="onDragEnd"
          class="flex-0-0"
        >
          <template #item="{ element: field }">
            <v-col v-if="matchesSearch(field)" cols="12">
              <v-row>
                <v-col cols="12" lg="6">
                  <field-list-item
                    :field="field"
                    :component-props="mapFieldToComponent(field)"
                    @edit="edit"
                    @toggle-visibility="toggleFieldVisibility"
                    @delete="deleteField"
                  />
                </v-col>
              </v-row>
            </v-col>
          </template>
        </draggable>
        <v-btn prepend-icon="mdi-plus" class="mr-2" variant="outlined" @click="isFieldBuilderDrawerOpen = true">{{ _('Add new field') }}</v-btn>
      </v-card-text>
    </v-card>
  </v-container>
</v-main>

{% endblock %} {% block outside %} {% endblock %} {% block js %}
<script src="/static/js/tinymce/js/tinymce/tinymce.min.js" referrerpolicy="origin"></script>
<script src="/static/js/tinymce-vue.min.js"></script>

<script src="/static/js/components/FieldListItem.js"></script>
<script src="/static/js/components/FieldBuilderDrawer.js"></script>
<script src="/static/js/components/PopDateField.js"></script>
<script src="/static/js/components/PopDateTimeField.js"></script>
<script src="/static/js/components/PopDateRangeField.js"></script>

<script src="/static/js/Sortable.min.js"></script>
<script src="/static/js/vuedraggable.umd.js"></script>

<script>
    const { createApp } = Vue;
    const { createVuetify } = Vuetify;
    const vuetify = createVuetify(vuetifyConfig);

    const app = createApp({
      delimiters: delimiters,
      mixins: [globalMixin],
      data: () => ({
        tinyConfig: tinyConfig,
        drawer: drawer,
        isFieldBuilderDrawerOpen: false,
        editedItem: {},
        search: '',
        dynamicFields: [],
        searchQuery: '',
        loading: false,
        originalFields: [],
      }),
      mounted() {
        this.fetchDynamicFields();
      },
      computed: {
        hasChanges() {
          const changes = this.computeChanges();
          return changes.create.length || changes.update.length || changes.delete.length;
        }
      },
      methods: {
        sortDynamicFields() {
          this.dynamicFields = this.dynamicFields.sort((a, b) => {
            if (a.sort_order === 0 && b.sort_order !== 0) return 1;  // a goes last
            if (b.sort_order === 0 && a.sort_order !== 0) return -1; // b goes last
            return a.sort_order - b.sort_order; // normal sort
          });
        },
        matchesSearch(field) {
          return !this.search || field.title?.toLowerCase().includes(this.search.toLowerCase());
        },
        edit(field) {
          const matchingField = this.dynamicFields.find(coreField => coreField.id === Number(field.fieldId))
          this.editedItem = matchingField;
          this.isFieldBuilderDrawerOpen = true;
        },
        saveField(evt) {
          const index = this.dynamicFields.findIndex(coreField => coreField.id === evt.id)

          if (index !== -1) {
            // Update existing field
            this.dynamicFields[index] = { ...evt } // or use Object.assign if you want to preserve the reference
          } else {
            // Add new field
            this.dynamicFields.push(evt)
          }

          this.sortDynamicFields()
        },
        async fetchDynamicFields() {
          try {
            const response = await axios.get('/admin/api/dynamic-fields/?entity_type=bulletin');
            this.dynamicFields = response.data.data;
            this.reindexZeroSortFields();
            this.sortDynamicFields();
            this.originalFields = JSON.parse(JSON.stringify(this.dynamicFields)); // deep clone
          } catch (err) {
            console.error(err);
            this.showSnack(handleRequestError(err));
          }
        },

        async save() {
          this.loading = true;
          try {
            const changes = this.computeChanges();

            // Create
            for (const f of changes.create) {
              await axios.post(`/admin/api/dynamic-fields/`, { item: f });
            }
            // Update (full object)
            for (const { id, item } of changes.update) {
              await axios.put(`/admin/api/dynamic-fields/${id}`, { item });
            }
            // Delete
            for (const id of changes.delete) {
              await axios.delete(`/admin/api/dynamic-fields/${id}`);
            }

            this.showSnack('{{ _("Fields saved successfully") }}');
            await this.fetchDynamicFields();
          } catch (err) {
            console.error(err);
            this.showSnack(handleRequestError(err));
          } finally {
            this.loading = false;
          }
        },

        computeChanges() {

          const changes = { create: [], update: [], delete: [] };
          const originalMap = new Map(this.originalFields.map(f => [f.id, f]));

          for (const field of this.dynamicFields) {
            if (!field.id) {
              // New dynamic field
              changes.create.push(field);
            } else {
              const orig = originalMap.get(field.id);
              if (orig) {
                // If anything at all changed, send full field object
                if (JSON.stringify(field) !== JSON.stringify(orig)) {
                  changes.update.push({ id: field.id, item: field });
                }
                originalMap.delete(field.id);
              }
            }
          }

          // Remaining originals are deleted (dynamic only)
          for (const field of originalMap.values()) {
            if (!field.core) {
              changes.delete.push(field.id);
            }
          }

          return changes;
        },
        
        mapFieldToComponent(coreField) {
          const baseProps = {
            fieldId: coreField.id,
            label: coreField.title,
            name: coreField.name,
            variant: 'filled',
            disabled: !coreField.active,
            hint: coreField?.ui_config?.help_text,
          };

          const componentMap = {
            text_input: { component: 'v-text-field', ...baseProps },
            multi_select: { component: 'v-select', ...baseProps, items: coreField.options, 'item-title': 'label', 'item-value': 'value', multiple: coreField.field_type === 'array' },
            dropdown: { component: 'v-select', ...baseProps, items: coreField.options, 'item-title': 'label', 'item-value': 'value', multiple: coreField.field_type === 'array' },
            text_area: { component: 'v-textarea', ...baseProps },
            checkbox: { component: 'v-checkbox', ...baseProps },
            switch: { component: 'v-switch', ...baseProps },
            date_picker: { component: 'pop-date-time-field' },
            editor: { component: 'tinymce-editor', init: tinyConfig, disabled: !coreField.active, fieldId: coreField.id },
          };

          const config = componentMap[coreField.ui_component];
          if (!config) return null;

          return config;
        },
        onDragEnd() {
          this.reindexFields()
        },
        reindexFields() {
          this.dynamicFields = this.dynamicFields.map((field, index) => ({ ...field, sort_order: index+1 }))
        },
        reindexZeroSortFields() {
          // Find max sort_order before first zero
          let maxOrder = 0;
          for (const field of this.dynamicFields) {
            if (field.sort_order === 0) break;
            if (field.sort_order > maxOrder) maxOrder = field.sort_order;
          }

          let counter = maxOrder + 1;

          this.dynamicFields = this.dynamicFields.map(field => {
            if (field.sort_order === 0) {
              return { ...field, sort_order: counter++ };
            }
            return field;
          });
        },
        async deleteField(field) {
          try {
            const matchingField = this.dynamicFields.find(coreField => coreField.id === Number(field.fieldId))
            matchingField.active = false
          } catch (err) {
            console.error(err);
            this.showSnack(handleRequestError(err));
          }
        },
        async toggleFieldVisibility(field) {
          try {
            const matchingField = this.dynamicFields.find(coreField => coreField.id === Number(field.fieldId))
            matchingField.active = !matchingField.active
          } catch (err) {
            console.error(err);
            this.showSnack(handleRequestError(err));
          }
        },
        closeDrawer(open) {
          this.isFieldBuilderDrawerOpen = open;

          if (!open) {
            this.editedItem = {}
          }
        }
      },
    });

    app.component('FieldListItem', FieldListItem);
    app.component('FieldBuilderDrawer', FieldBuilderDrawer);
    app.component('draggable', vuedraggable);
    app.component('tinymce-editor', Editor);
    app.component('PopDateField', PopDateField);
    app.component('PopDateRangeField', PopDateRangeField);
    app.component('PopDateTimeField', PopDateTimeField);

    app.use(router);
    app.use(vuetify).mount('#app');

    window.app = app;
</script>
{% endblock %}
